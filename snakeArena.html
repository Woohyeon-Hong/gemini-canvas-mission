<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>스네이크 아레나</title>
  <style>
    :root {
      --bg-color: #020617; /* 더 어두운 전체 배경 */
      --p1-color: #06b6d4; /* Cyan */
      --p2-color: #ec4899; /* Pink */
      --food-color: #22c55e; /* Green */
      --item-color: #eab308; /* Yellow */
      --danger-color: #ef4444; /* Red */
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* 다시 화면 중앙 배치 */
      min-height: 100vh;
      overflow: hidden; /* 스크롤 완전히 차단 */
      box-sizing: border-box;
    }

    header {
      text-align: center;
      margin-bottom: 10px;
    }

    h1 {
      margin: 0;
      font-size: 1.8rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .hud {
      display: flex;
      justify-content: space-between;
      width: 450px; /* 캔버스 크기에 맞춤 */
      margin-bottom: 10px;
      padding: 10px 15px;
      background: rgba(30, 41, 59, 0.8);
      border-radius: 8px;
      box-sizing: border-box;
      box-shadow: 0 4px 6px rgba(0,0,0,0.5);
      border: 1px solid #334155;
    }

    .player-stats {
      display: flex;
      flex-direction: column;
    }

    .p1-stats { color: var(--p1-color); }
    .p2-stats { color: var(--p2-color); text-align: right; }

    .stat-score { font-size: 1.5rem; font-weight: bold; }
    .stat-buff { font-size: 0.85rem; height: 1.2rem; margin-top: 5px; color: var(--item-color); }

    .center-hud {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--danger-color);
      font-weight: bold;
    }

    #shrink-timer {
      font-size: 1.5rem;
      text-shadow: 0 0 8px var(--danger-color);
    }

    .game-container {
      position: relative;
      box-shadow: 0 0 25px rgba(0,0,0,0.8);
      border-radius: 8px;
      overflow: hidden;
      border: 2px solid #334155;
    }

    canvas {
      background-color: #0f172a;
      display: block;
    }

    /* 공통 오버레이 스타일 (시작, 카운트다운, 게임오버) */
    .overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(2, 6, 23, 0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
      z-index: 10;
    }

    .overlay.active {
      display: flex;
    }

    .rules-box {
      background: rgba(30, 41, 59, 0.95);
      padding: 20px 30px;
      border-radius: 10px;
      margin-bottom: 30px;
      border: 2px solid #334155;
      max-width: 80%;
      text-align: left;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }

    .rules-box h2 {
      margin-top: 0;
      color: var(--item-color);
      text-align: center;
      font-size: 1.5rem;
      margin-bottom: 15px;
    }

    .rules-box ul {
      padding-left: 20px;
      line-height: 1.6;
      margin-bottom: 0;
    }

    .rules-box li {
      margin-bottom: 8px;
    }

    #result-msg {
      font-size: 2.5rem;
      font-weight: bold;
      margin-bottom: 20px;
      text-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }

    #countdown-text {
      font-size: 6rem;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }

    button {
      padding: 12px 30px;
      font-size: 1.2rem;
      font-weight: bold;
      color: #fff;
      background: linear-gradient(45deg, var(--p1-color), var(--p2-color));
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }

    button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    }

    .instructions {
      margin-top: 20px;
      display: flex;
      gap: 30px;
      color: #94a3b8;
      font-size: 0.9rem;
      text-align: center;
    }

    .key-hint {
      display: inline-block;
      background: #334155;
      padding: 3px 8px;
      border-radius: 4px;
      margin: 0 2px;
      color: #fff;
      font-weight: bold;
    }
  </style>
</head>
<body>

<header>
  <h1>스네이크 아레나</h1>
</header>

<div class="hud">
  <div class="player-stats p1-stats">
    <div style="font-size: 0.8rem; color: #cbd5e1; margin-bottom: 3px;">P1 (WASD)</div>
    <div>길이: <span id="p1-score" class="stat-score">3</span></div>
    <div id="p1-buff" class="stat-buff"></div>
  </div>
  <div class="center-hud">
    <div style="font-size: 0.8rem; color: #cbd5e1;">맵 축소까지</div>
    <div id="shrink-timer">10.0s</div>
  </div>
  <div class="player-stats p2-stats">
    <div style="font-size: 0.8rem; color: #cbd5e1; margin-bottom: 3px;">P2 (방향키)</div>
    <div>길이: <span id="p2-score" class="stat-score">3</span></div>
    <div id="p2-buff" class="stat-buff"></div>
  </div>
</div>

<div class="game-container">
  <canvas id="gameCanvas" width="450" height="450"></canvas>

  <!-- 시작 화면 오버레이 -->
  <div id="start-screen" class="overlay active">
    <div class="rules-box">
      <h2>게임 규칙</h2>
      <ul>
        <li><strong>승리 조건:</strong> 길이 <span style="color: var(--item-color); font-weight: bold;">15</span>를 먼저 달성하거나 상대방을 제거하세요.</li>
        <li><strong>아이템:</strong> 초록 사과(길이+1), 노란 별(상대방 5초간 가속 패널티)</li>
        <li><strong>배틀로얄:</strong> 10초마다 맵이 줄어듭니다. 붉은 테두리를 피하세요!</li>
        <li><strong>충돌 패배:</strong> 벽, 자신의 몸, 상대방의 몸통에 닿으면 즉시 패배합니다.</li>
      </ul>
    </div>
    <button onclick="triggerCountdown()">게임 시작</button>
  </div>

  <!-- 카운트다운 오버레이 -->
  <div id="countdown-screen" class="overlay">
    <div id="countdown-text">3</div>
  </div>

  <!-- 게임 종료 오버레이 -->
  <div id="game-over-screen" class="overlay">
    <div id="result-msg">P1 승리!</div>
    <button onclick="triggerCountdown()">다시 시작</button>
  </div>
</div>

<div class="instructions">
  <div><span class="key-hint">P1</span> WASD</div>
  <div><span class="key-hint">P2</span> 화살표</div>
</div>

<script>
  // --------------------------------------------------------
  // 1. 상수 및 캔버스 설정
  // --------------------------------------------------------
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const GRID_SIZE = 25;
  const CELL_SIZE = canvas.width / GRID_SIZE; // 18px

  const SHRINK_INTERVAL = 10000;
  const WARNING_TIME = 5000;
  const BASE_MOVE_DELAY = 160;

  // --------------------------------------------------------
  // 2. 게임 상태 관리 변수
  // --------------------------------------------------------
  let p1, p2;
  let food = null;
  let speedItem = null;
  let speedItemSpawnTimer = 0;

  let mapBounds = { minX: 0, maxX: GRID_SIZE - 1, minY: 0, maxY: GRID_SIZE - 1 };
  let shrinkTimer = 0;

  let lastTime = 0;
  let animationFrameId;
  let isGameOver = true;

  const uiElements = {
    p1Score: document.getElementById('p1-score'),
    p2Score: document.getElementById('p2-score'),
    p1Buff: document.getElementById('p1-buff'),
    p2Buff: document.getElementById('p2-buff'),
    shrinkTimer: document.getElementById('shrink-timer'),

    startScreen: document.getElementById('start-screen'),
    countdownScreen: document.getElementById('countdown-screen'),
    countdownText: document.getElementById('countdown-text'),
    gameOverScreen: document.getElementById('game-over-screen'),
    resultMsg: document.getElementById('result-msg')
  };

  // --------------------------------------------------------
  // 3. 초기화 로직 및 카운트다운
  // --------------------------------------------------------
  function createPlayer(id, startX, startY, startDirX, startDirY, color, headColor) {
    return {
      id: id,
      body: [
        {x: startX, y: startY},
        {x: startX - startDirX, y: startY - startDirY},
        {x: startX - startDirX * 2, y: startY - startDirY * 2}
      ],
      dir: {x: startDirX, y: startDirY},
      nextDir: {x: startDirX, y: startDirY},
      color: color,
      headColor: headColor,
      moveTimer: 0,
      speedMultiplier: 1,
      speedBuffTimer: 0,
      isDead: false
    };
  }

  // 카운트다운 로직
  function triggerCountdown() {
    uiElements.startScreen.classList.remove('active');
    uiElements.gameOverScreen.classList.remove('active');
    uiElements.countdownScreen.classList.add('active');

    let count = 3;
    uiElements.countdownText.innerText = count;

    setupGameData();
    draw();

    const interval = setInterval(() => {
      count--;
      if (count > 0) {
        uiElements.countdownText.innerText = count;
      } else if (count === 0) {
        uiElements.countdownText.innerText = "START!";
      } else {
        clearInterval(interval);
        uiElements.countdownScreen.classList.remove('active');
        startGame();
      }
    }, 1000);
  }

  function setupGameData() {
    mapBounds = { minX: 0, maxX: GRID_SIZE - 1, minY: 0, maxY: GRID_SIZE - 1 };
    shrinkTimer = 0;
    speedItemSpawnTimer = 0;

    p1 = createPlayer(1, 3, 3, 1, 0, '#06b6d4', '#22d3ee');
    p2 = createPlayer(2, GRID_SIZE - 4, GRID_SIZE - 4, -1, 0, '#ec4899', '#f472b6');

    spawnObject('food');
    speedItem = null;
    updateUI();
  }

  function startGame() {
    isGameOver = false;
    lastTime = performance.now();
    cancelAnimationFrame(animationFrameId);
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function spawnObject(type) {
    let newPos;
    let isValid = false;
    while (!isValid) {
      newPos = {
        x: Math.floor(Math.random() * (mapBounds.maxX - mapBounds.minX + 1)) + mapBounds.minX,
        y: Math.floor(Math.random() * (mapBounds.maxY - mapBounds.minY + 1)) + mapBounds.minY
      };

      // 아직 플레이어가 생성되지 않은 경우를 위한 안전 장치
      const onP1 = p1 ? p1.body.some(seg => seg.x === newPos.x && seg.y === newPos.y) : false;
      const onP2 = p2 ? p2.body.some(seg => seg.x === newPos.x && seg.y === newPos.y) : false;
      const onFood = food && food.x === newPos.x && food.y === newPos.y;
      const onSpeed = speedItem && speedItem.x === newPos.x && speedItem.y === newPos.y;

      if (!onP1 && !onP2 && !onFood && !onSpeed) isValid = true;
    }

    if (type === 'food') food = newPos;
    if (type === 'speed') speedItem = newPos;
  }

  // --------------------------------------------------------
  // 4. 메인 루프 및 업데이트
  // --------------------------------------------------------
  function gameLoop(currentTime) {
    if (isGameOver) return;

    let dt = currentTime - lastTime;
    lastTime = currentTime;
    if (dt > 100) dt = 100;

    update(dt);
    draw();

    if (!isGameOver) {
      animationFrameId = requestAnimationFrame(gameLoop);
    }
  }

  function update(dt) {
    shrinkTimer += dt;
    if (shrinkTimer >= SHRINK_INTERVAL) {
      shrinkTimer = 0;
      shrinkMap();
    }

    if (!speedItem) {
      speedItemSpawnTimer += dt;
      if (speedItemSpawnTimer > 8000) {
        spawnObject('speed');
        speedItemSpawnTimer = 0;
      }
    }

    updatePlayerBuff(p1, dt);
    updatePlayerBuff(p2, dt);

    p1.moveTimer += dt;
    const p1CurrentDelay = BASE_MOVE_DELAY / p1.speedMultiplier;
    if (p1.moveTimer >= p1CurrentDelay) {
      p1.moveTimer -= p1CurrentDelay;
      movePlayer(p1);
      checkPlayerInteraction(p1);
    }

    p2.moveTimer += dt;
    const p2CurrentDelay = BASE_MOVE_DELAY / p2.speedMultiplier;
    if (p2.moveTimer >= p2CurrentDelay) {
      p2.moveTimer -= p2CurrentDelay;
      movePlayer(p2);
      checkPlayerInteraction(p2);
    }

    checkCollisions();

    // 승리 조건: 길이 15 달성 여부 체크
    if (!isGameOver) {
      if (p1.body.length >= 15 && p2.body.length >= 15) {
        endGame("무승부! (동시 15 달성)", "#fff");
      } else if (p1.body.length >= 15) {
        endGame("P1 승리! (길이 15 달성)", "var(--p1-color)");
      } else if (p2.body.length >= 15) {
        endGame("P2 승리! (길이 15 달성)", "var(--p2-color)");
      }
    }

    updateUI();
  }

  function updatePlayerBuff(player, dt) {
    if (player.speedBuffTimer > 0) {
      player.speedBuffTimer -= dt;
      if (player.speedBuffTimer <= 0) {
        player.speedBuffTimer = 0;
        player.speedMultiplier = 1;
      }
    }
  }

  function movePlayer(player) {
    player.dir = player.nextDir;
    const head = { x: player.body[0].x + player.dir.x, y: player.body[0].y + player.dir.y };
    player.body.unshift(head);
  }

  function checkPlayerInteraction(player) {
    const head = player.body[0];

    if (food && head.x === food.x && head.y === food.y) {
      spawnObject('food');
    } else {
      player.body.pop();
    }

    if (speedItem && head.x === speedItem.x && head.y === speedItem.y) {
      const targetPlayer = (player.id === 1) ? p2 : p1;
      applySpeedDebuff(targetPlayer);
      spawnObject('speed');
    }
  }

  function applySpeedDebuff(targetPlayer) {
    targetPlayer.speedMultiplier *= 2;
    targetPlayer.speedBuffTimer = 5000;
  }

  function checkCollisions() {
    const h1 = p1.body[0];
    const h2 = p2.body[0];

    if (isOutOfBounds(h1)) p1.isDead = true;
    if (isOutOfBounds(h2)) p2.isDead = true;

    if (h1.x === h2.x && h1.y === h2.y) {
      if (p1.body.length > p2.body.length) p2.isDead = true;
      else if (p2.body.length > p1.body.length) p1.isDead = true;
      else { p1.isDead = true; p2.isDead = true; }
    }

    for (let i = 1; i < p1.body.length; i++) {
      if (h1.x === p1.body[i].x && h1.y === p1.body[i].y) p1.isDead = true;
      if (h2.x === p1.body[i].x && h2.y === p1.body[i].y) p2.isDead = true;
    }
    for (let i = 1; i < p2.body.length; i++) {
      if (h2.x === p2.body[i].x && h2.y === p2.body[i].y) p2.isDead = true;
      if (h1.x === p2.body[i].x && h1.y === p2.body[i].y) p1.isDead = true;
    }

    if (p1.isDead || p2.isDead) endGame();
  }

  function isOutOfBounds(pos) {
    return pos.x < mapBounds.minX || pos.x > mapBounds.maxX || pos.y < mapBounds.minY || pos.y > mapBounds.maxY;
  }

  function shrinkMap() {
    if (mapBounds.maxX - mapBounds.minX <= 10) return;

    mapBounds.minX++;
    mapBounds.maxX--;
    mapBounds.minY++;
    mapBounds.maxY--;

    if (isOutOfBounds(p1.body[0])) p1.isDead = true;
    if (isOutOfBounds(p2.body[0])) p2.isDead = true;

    if (food && isOutOfBounds(food)) spawnObject('food');
    if (speedItem && isOutOfBounds(speedItem)) spawnObject('speed');

    if (p1.isDead || p2.isDead) endGame();
  }

  function endGame(customMsg, customColor) {
    isGameOver = true;
    uiElements.gameOverScreen.classList.add('active');

    if (customMsg) {
      uiElements.resultMsg.innerText = customMsg;
      uiElements.resultMsg.style.color = customColor;
    } else {
      if (p1.isDead && p2.isDead) {
        uiElements.resultMsg.innerText = "무승부! (동시 사망)";
        uiElements.resultMsg.style.color = "#fff";
      } else if (p1.isDead) {
        uiElements.resultMsg.innerText = "P2 승리!";
        uiElements.resultMsg.style.color = "var(--p2-color)";
      } else if (p2.isDead) {
        uiElements.resultMsg.innerText = "P1 승리!";
        uiElements.resultMsg.style.color = "var(--p1-color)";
      }
    }
  }

  // --------------------------------------------------------
  // 5. 렌더링
  // --------------------------------------------------------
  function draw() {
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#334155';
    const mapW = (mapBounds.maxX - mapBounds.minX + 1) * CELL_SIZE;
    const mapH = (mapBounds.maxY - mapBounds.minY + 1) * CELL_SIZE;
    ctx.fillRect(mapBounds.minX * CELL_SIZE, mapBounds.minY * CELL_SIZE, mapW, mapH);

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    for(let i = mapBounds.minX; i <= mapBounds.maxX; i++) {
      ctx.beginPath();
      ctx.moveTo(i * CELL_SIZE, mapBounds.minY * CELL_SIZE);
      ctx.lineTo(i * CELL_SIZE, (mapBounds.maxY + 1) * CELL_SIZE);
      ctx.stroke();
    }
    for(let i = mapBounds.minY; i <= mapBounds.maxY; i++) {
      ctx.beginPath();
      ctx.moveTo(mapBounds.minX * CELL_SIZE, i * CELL_SIZE);
      ctx.lineTo((mapBounds.maxX + 1) * CELL_SIZE, i * CELL_SIZE);
      ctx.stroke();
    }

    const timeUntilShrink = SHRINK_INTERVAL - shrinkTimer;
    if (timeUntilShrink <= WARNING_TIME && (mapBounds.maxX - mapBounds.minX > 10)) {
      if (Math.floor(Date.now() / 250) % 2 === 0) {
        ctx.fillStyle = 'rgba(239, 68, 68, 0.6)';
        const w = mapBounds.maxX - mapBounds.minX + 1;
        const h = mapBounds.maxY - mapBounds.minY + 1;
        ctx.fillRect(mapBounds.minX * CELL_SIZE, mapBounds.minY * CELL_SIZE, w * CELL_SIZE, CELL_SIZE);
        ctx.fillRect(mapBounds.minX * CELL_SIZE, mapBounds.maxY * CELL_SIZE, w * CELL_SIZE, CELL_SIZE);
        ctx.fillRect(mapBounds.minX * CELL_SIZE, mapBounds.minY * CELL_SIZE, CELL_SIZE, h * CELL_SIZE);
        ctx.fillRect(mapBounds.maxX * CELL_SIZE, mapBounds.minY * CELL_SIZE, CELL_SIZE, h * CELL_SIZE);
      }
    }

    if (food) drawCell(food.x, food.y, '#22c55e', true);
    if (speedItem) drawItem(speedItem.x, speedItem.y, '#eab308');

    if (p1) drawSnake(p1);
    if (p2) drawSnake(p2);
  }

  function drawCell(x, y, color, isCircle = false) {
    ctx.fillStyle = color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = color;

    if (isCircle) {
      ctx.beginPath();
      ctx.arc(x * CELL_SIZE + CELL_SIZE/2, y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2 - 2, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
    }
    ctx.shadowBlur = 0;
  }

  function drawItem(x, y, color) {
    ctx.fillStyle = color;
    ctx.shadowBlur = 15;
    ctx.shadowColor = color;
    ctx.beginPath();
    const cx = x * CELL_SIZE + CELL_SIZE/2;
    const cy = y * CELL_SIZE + CELL_SIZE/2;
    ctx.moveTo(cx, cy - CELL_SIZE/2 + 2);
    ctx.lineTo(cx + CELL_SIZE/2 - 2, cy);
    ctx.lineTo(cx, cy + CELL_SIZE/2 - 2);
    ctx.lineTo(cx - CELL_SIZE/2 + 2, cy);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  function drawSnake(player) {
    player.body.forEach((segment, index) => {
      const color = index === 0 ? player.headColor : player.color;
      drawCell(segment.x, segment.y, color, index === 0);

      if (index === 0) {
        ctx.fillStyle = '#fff';
        const cx = segment.x * CELL_SIZE + CELL_SIZE/2;
        const cy = segment.y * CELL_SIZE + CELL_SIZE/2;
        const eyeOffset = 4;

        if (player.dir.x !== 0) {
          ctx.fillRect(cx + (player.dir.x * eyeOffset) - 1.5, cy - eyeOffset - 1.5, 3, 3);
          ctx.fillRect(cx + (player.dir.x * eyeOffset) - 1.5, cy + eyeOffset - 1.5, 3, 3);
        } else {
          ctx.fillRect(cx - eyeOffset - 1.5, cy + (player.dir.y * eyeOffset) - 1.5, 3, 3);
          ctx.fillRect(cx + eyeOffset - 1.5, cy + (player.dir.y * eyeOffset) - 1.5, 3, 3);
        }
      }
    });
  }

  function updateUI() {
    if(!p1 || !p2) return;
    uiElements.p1Score.innerText = p1.body.length;
    uiElements.p2Score.innerText = p2.body.length;

    uiElements.p1Buff.innerText = p1.speedMultiplier > 1 ? `가속 x${p1.speedMultiplier} (${(p1.speedBuffTimer/1000).toFixed(1)}s)` : '';
    uiElements.p2Buff.innerText = p2.speedMultiplier > 1 ? `가속 x${p2.speedMultiplier} (${(p2.speedBuffTimer/1000).toFixed(1)}s)` : '';

    let remainTime = Math.max(0, (SHRINK_INTERVAL - shrinkTimer) / 1000).toFixed(1);
    uiElements.shrinkTimer.innerText = remainTime + "s";

    if (SHRINK_INTERVAL - shrinkTimer <= WARNING_TIME) {
      uiElements.shrinkTimer.style.color = Math.floor(Date.now() / 250) % 2 === 0 ? '#ef4444' : '#fff';
    } else {
      uiElements.shrinkTimer.style.color = '#ef4444';
    }
  }

  // --------------------------------------------------------
  // 6. 키보드 입력 처리
  // --------------------------------------------------------
  window.addEventListener('keydown', (e) => {
    if (isGameOver) return;

    if (e.key === 'w' || e.key === 'W') { if (p1.dir.y !== 1) p1.nextDir = {x: 0, y: -1}; }
    if (e.key === 's' || e.key === 'S') { if (p1.dir.y !== -1) p1.nextDir = {x: 0, y: 1}; }
    if (e.key === 'a' || e.key === 'A') { if (p1.dir.x !== 1) p1.nextDir = {x: -1, y: 0}; }
    if (e.key === 'd' || e.key === 'D') { if (p1.dir.x !== -1) p1.nextDir = {x: 1, y: 0}; }

    if (e.key === 'ArrowUp') { if (p2.dir.y !== 1) p2.nextDir = {x: 0, y: -1}; }
    if (e.key === 'ArrowDown') { if (p2.dir.y !== -1) p2.nextDir = {x: 0, y: 1}; }
    if (e.key === 'ArrowLeft') { if (p2.dir.x !== 1) p2.nextDir = {x: -1, y: 0}; }
    if (e.key === 'ArrowRight') { if (p2.dir.x !== -1) p2.nextDir = {x: 1, y: 0}; }

    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
      e.preventDefault();
    }
  });

  draw();
</script>
</body>
</html>