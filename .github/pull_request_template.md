## ✅ 제출 체크리스트

- [x] 4개 웹앱 제출 (유틸리티 앱 1개 + 게임 1개 + 학습 앱 1개 + 페어 프롬프트 릴레이 1개)
- [x] 최소 1개 앱에 Gemini AI 기능 포함
- [x] 모든 앱이 배포 링크로 정상 동작함
- [x] AI 사용 일지 작성 완료

## 💻 1. 유틸리티 앱

## 앱 이름: ChronoCoach

### 배포 링크

https://gemini.google.com/share/d9d880188ef4

### 이 앱을 만든 이유

- 어떤 문제/불편함을 해결하려고 했나요?

많은 사람들이 공부, 운동, 독서, 사이드 프로젝트 등 다양한 활동에 시간을 투자하지만, 실제로 내가 무엇에 얼마나 몰두했는지 정확히 인지하지 못하는 경우가 많습니다.

막연히 “열심히 했다”고 느끼는 것과, 구체적인 시간 데이터를 기반으로 스스로를 평가하는 것은 큰 차이가 있습니다. 또한 기록을 하더라도 단순한 시간 누적에 그치고, 이를 바탕으로 어떻게 개선해야 할지에 대한 피드백은 부족한 경우가 많습니다.

ChronoCoach는 사용자가 자신의 활동 시간을 체계적으로 기록하고, 이를 분석하여 더 나은 방향으로 개선할 수 있도록 돕기 위해 개발되었습니다.

- 이 앱을 언제, 어떻게 사용할 건가요?

**집중 시간 기록이 필요할 때**

공부나 업무를 시작할 때 기록을 시작하고, 종료 시점을 명확히 남김으로써 실제 몰입 시간을 확인할 수 있습니다.

**주간/월간 성과를 점검하고 싶을 때**

이번 주에 운동을 얼마나 했는지, 한 달 동안 프로젝트에 얼마나 시간을 쏟았는지를 데이터 기반으로 확인할 수 있습니다.

**스스로에게 동기부여가 필요할 때**

누적된 기록과 AI 분석 리포트를 통해 자신의 패턴을 객관적으로 바라보고, 개선 방향을 설정할 수 있습니다.

### 주요 기능

- **활동 등록 및 관리:** 사용자는 공부, 운동, 독서, 업무 등 자신이 기록하고 싶은 활동을 자유롭게 등록할 수 있습니다. 이미 등록된 활동은 쉽게 선택할 수 있고, 새로운 활동이 필요할 경우 직접 추가할 수 있습니다.
- **집중 시간 기록:** 특정 활동에 대한 활동 시간을 기록할 수 있습니다. 만약 활동 도중 날짜가 변경되면, 기록은 자동으로 날짜에 맞게 나뉘어 저장됩니다.
- **하루 단위 활동 확인:** 오늘 내가 어떤 활동에 몇 시간을 사용했는지 한눈에 확인할 수 있습니다. 이를 통해 하루의 시간 사용 패턴을 직관적으로 파악할 수 있습니다.
- **주간·월간·연간 누적 통계 제공:** 이번 주, 이번 달, 올해 동안 각 활동에 얼마나 시간을 투자했는지 누적 데이터를 제공합니다. 장기적인 습관 형성과 성과 추적을 돕습니다.
- **주간 리포트 제공:** 최근 7일간의 활동 기록을 바탕으로 한 주를 돌아볼 수 있는 요약 리포트를 제공합니다. 활동 비중과 패턴을 정리해주며, 다음 주를 위한 방향성을 제안합니다.
- **개선 방향 제안:** 특정 활동에 시간이 과도하게 치우쳤거나, 목표 대비 부족한 부분이 있다면 이를 알려주고 균형 잡힌 시간 사용을 위한 제안을 제공합니다.

### AI 기능

- 어떤 AI 기능을 추가했나요?
    - 최근 7일간 활동 기록을 바탕으로 주간 평가 생성
    - 활동 유형별 비율 분석
    - 사용자 패턴 기반 개선 제안 리포트 생성
  
- AI 기능이 앱에서 어떤 역할을 하나요?
AI는 단순 통계 제공자가 아니라 개인 맞춤형 자기관리 코치 역할을 수행합니다.

사용자의 기록을 분석하여:

- 특정 활동에 시간이 과도하게 편중되었는지
- 목표 대비 부족한 활동이 무엇인지
- 일정한 루틴이 형성되고 있는지

를 평가하고, 다음 주에 어떻게 시간을 배분하면 좋을지 구체적인 개선 방향을 제안합니다.

이를 통해 사용자는 단순히 시간을 기록하는 것을 넘어, 자신의 시간 사용 패턴을 인지하고 스스로를 개선하는 경험을 할 수 있습니다.



## 🎮 2. 게임

## 앱 이름: 우아한 야바위

### 배포 링크

- https://gemini.google.com/share/4c0a9c8b792b

### 이 앱을 만든 이유

- 어떤 문제/불편함을 해결하려고 했나요?

‘우아한 야바위'는 익숙한 고전 게임을 현대적이고 감각적인 디자인으로 재구성하여, 사용자에게 몰입감 있는 디지털 휴식을 제공하기 위해 기획되었습니다. 단순히 운에 의존하는 것이 아니라 사용자의 실력에 맞춰 난이도가 최적화되는 구조를 통해 지속적인 재미와 도전 의식을 자극하도록 하였습니다.

- 이 앱을 언제, 어떻게 사용할 건가요?

**일상 속 짧은 '기분 전환'**

학습 중 잠시 뇌를 식히고 싶을 때, 1분 내외로 가볍게 즐기는 전환용 콘텐츠를 타겟팅하였습니다. 짧고 강렬한 집중력을 요구하는 게임 특성상 휴식 후 집중력 환기 효과를 기대할 수 있습니다.

**공정한 실력 기반의 가벼운 내기**

승률에 따라 섞기 속도가 정교하게 변하므로, 지인들과 함께 누가 더 높은 난이도를 극복하는지 겨루는 엔터테인먼트 도구로 활용할 수 있습니다.

### 주요 기능

- **플레이어 인식 및 등록**: 닉네임을 통해 기존 플레이어인지 확인하고, 처음 온 플레이어에게는 새로운 계정 생성을 제안합니다.
- **난이도 설정**: 게임에 사용할 컵의 개수를 직접 정하여, 본인에게 맞는 난이도를 선택할 수 있습니다.
- **공 숨기기**: 긴장감을 유지하기 위해 선택된 컵들 중 하나에 무작위로 공을 숨깁니다.
- **정답 확인**: 선택한 컵을 열어 공의 유무를 확인하고, 그에 따른 승패 결과를 즉시 알려줍니다.
- **전적 자동 저장**: 매 판이 끝날 때마다 승리 기록과 참여 횟수를 누락 없이 기록하여 플레이어의 전적을 기록합니다.
- **실시간 승률 분석**: 누적된 기록을 바탕으로 현재 플레이어의 승률을 계산하여 화면에 표시합니다.
- **승률 기반 속도 조정:** 승률을 기반으로 컵을 섞는 속도를 조정합니다.
- **다음 게임 이어하기**: 한 판이 끝난 후, 곧바로 다음 도전을 이어갈지 혹은 여기서 게임을 마무리할지 결정합니다.

## 📚 3. 학습 앱

## 앱 이름: Loop2Stream

### 배포 링크

https://gemini.google.com/share/a60a3f45ff75

### 이 앱을 만든 이유

- 어떤 문제/불편함을 해결하려고 했나요?

Java Stream API는 많은 개발자들이 개념적으로는 이해하고 있지만, 실제 문제 해결 상황에서 자연스럽게 활용하지 못하는 경우가 많습니다. 특히 반복문(for) 중심 사고에 익숙한 개발자들은 Stream을 “알고는 있지만 쓰지 않는” 상태에 머무르는 경우가 많습니다.

Loop2Stream은 이러한 학습 간극을 줄이기 위해 개발되었습니다. 단순 문법 암기가 아니라, 실제 상황을 가정한 문제를 반복적으로 풀어보며 Stream 기반 사고로 전환할 수 있도록 돕는 것을 목표로 합니다.

- 이 앱을 언제, 어떻게 사용할 건가요?

**Stream 학습 직후 실전 감각을 키우고 싶을 때**

Stream 문법을 학습한 뒤, 실제 코드에 적용하는 연습이 필요할 때 사용합니다. 이론을 실전으로 연결하는 훈련 도구로 활용할 수 있습니다.

**코딩 테스트 또는 백엔드 학습 중 역량 점검용**

자신이 Stream을 얼마나 자연스럽게 활용할 수 있는지 점검하고 싶을 때, 난이도와 문제 개수를 설정하여 맞춤형 퀴즈를 풀 수 있습니다.

**반복문 중심 사고에서 벗어나고 싶을 때**

기존의 for문 위주 코드를 Stream 스타일로 전환하는 연습을 통해 코드의 가독성과 표현력을 개선하는 데 활용할 수 있습니다.

### 주요 기능

- **문제 개수 설정**: 사용자가 원하는 문제 개수를 직접 선택하여 퀴즈 문항 개수를 조절할 수 있습니다.
- **난이도 선택 기능**: 상/중/하 중 하나를 선택하여 본인의 수준에 맞는 문제를 풀이할 수 있습니다.
- **실전형 Stream 퀴즈 출제**: 단순 문법 문제가 아닌, 실제 사용 사례를 가정한 문제를 제공합니다.
- **코드 제출 기능**: 사용자가 직접 Java 코드를 작성하여 제출할 수 있습니다.
- **자동 채점 시스템**: 제출된 코드에 대해 정답 여부를 자동으로 판별합니다.
- **종합 학습 리포트 제공**: 모든 문제 풀이가 완료되면 정답률과 코드 분석 결과를 종합하여 제공합니다.
- **코드 개선 가이드 제안**: 더 나은 Stream 활용 방식이 있을 경우 대안을 함께 제시합니다.

### AI 기능

- 어떤 AI 기능을 추가했나요?
    - Stream API를 활용할 수 있는 문제 생성
    - 사용자 코드에 대한 채점
    - 코드 품질 분석 (가독성, 연산 조합 적절성, 불필요한 연산 여부 등)
    - 개인 맞춤형 종합 학습 리포트 생성
  
- AI 기능이 앱에서 어떤 역할을 하나요?
AI는 단순 채점기가 아니라 **개인 맞춤형 코드 리뷰어 역할**을 수행합니다.

사용자가 작성한 코드를 분석하여:

- Stream 사용이 적절했는지
- 더 간결하거나 표현력 있는 방식이 있는지
- 불필요한 반복이나 비효율적인 체이닝은 없는지

를 평가하고, 학습 결과를 바탕으로 강점과 개선점을 정리한 리포트를 제공합니다.

이를 통해 사용자는 단순히 정답을 맞히는 것을 넘어, Stream 기반 사고를 체득하는 것을 목표로 합니다.

## 🤝 4. 페어 프롬프트 릴레이 앱

## 앱 이름: 스네이크 아레나

### 페어
@mvg01

### 배포 링크

https://gemini.google.com/share/0b5291ed424d

### 이 앱을 만든 이유

- 어떤 문제/불편함을 해결하려고 했나요?
    - **기존 복불복 게임의 지루함:** 사다리 타기, 룰렛 등 기존의 내기 게임은 오직 운에만 의존하여 플레이 과정 자체의 재미나 몰입감이 부족합니다.
    - **정통 지렁이 게임의 루즈함:** 클래식 지렁이 게임은 단순히 오래 살아남는 것이 목적이기에, 대전용으로 즐기기에는 플레이 타임이 길어지고 긴장감이 떨어지는 한계가 있습니다.
    - **차별화된 해결책 (빠른 템포와 변수 창출):** 10초마다 맵이 좁아지는 배틀로얄 요소를 도입하고, 축소 5초 전 점멸 효과를 주어 플레이어들에게 강한 심리적 압박감을 제공합니다.
        - 획득 시 상대방의 속도를 늦추거나 빠르게 만드는 아이템을 통해 예측 불가능한 변수를 만듭니다. 이를 통해 단시간 안에 실력과 운이 교차하는 짜릿한 승부를 유도하여 기존 내기 게임의 불편함을 해결했습니다.
- 이 앱을 언제, 어떻게 사용할 건가요?
    - 크루원들과 모여서 식사나 휴식을 취할 때, 빠르고 유쾌하게 내기를 하는 상황에서 사용합니다.

### 주요 기능

- **2인용 로컬 조작:** 1P는 W, A, S, D 키로, 2P는 키보드 방향키로 각각의 지렁이를 동시에 조작합니다.
- **배틀로얄 맵 축소:** 10초 단위로 맵의 외곽 크기가 점진적으로 줄어들어 플레이 공간을 강제로 압박합니다.
- **축소 사전 경고:** 맵이 줄어들기 5초 전, 사라질 예정인 외곽 칸들이 점멸하며 시각적인 압박감과 경고를 제공합니다.
- **속도 증폭 아이템:** 획득 시 상대방의 이동 속도를 일정 시간 동안 2배로 강제 증가시켜 템포를 뺏고 조작 실수를 유도합니다.
- **아이템 효과 중첩:** 효과가 끝나기 전에 추가 획득 시 곱연산이 적용되어 상대의 속도가 4배, 8배로 감당하기 힘들게 빨라집니다.
- **독립적 오브젝트 생성:** 먹이와 아이템은 맵 상에 각각 최대 1개씩 유지되며, 획득 즉시 지렁이가 없는 빈칸에 무작위로 재생성됩니다.
- **몸통 충돌 패배:** 자신의 지렁이 머리가 상대방의 몸통(꼬리 포함)에 닿거나 맵 밖으로 나가면 즉시 패배합니다.
- **정면 충돌 판정:** 서로의 머리가 부딪히는 상황에서는 몸통 길이가 더 긴 플레이어가 승리하며, 길이가 같을 경우 무승부 처리됩니다.


## 📝 AI 사용 일지 
- 본인 기준으로 가장 잘 만들어진 앱 1개를 골라주세요.
- 아래 불릿 포인트는 예시입니다. 각 항목의 취지를 참고해 본인의 실제 경험을 중심으로 자유롭게 작성해 주세요.

### 대상 앱 이름 Loop2Stream

### 1. 초기 프롬프트

```
지금부터  JAVA stream API 연습을 위한 웹앱을 개발해보자. 이 앱에 대한 개요는 다음과 같아.

주요 타겟

Java Stream API의 기본 문법과 개념은 이해하고 있지만, 실제 서비스 코드나 문제 해결 상황에서 이를 자연스럽게 활용하지 못하는 개발자를 대상으로 한다.

특히 다음과 같은 개발자를 주요 사용자로 설정한다.

- for문을 Stream으로 전환하는 데 어려움을 느끼는 개발자
- map, filter, collect 등의 개념은 알지만, 조합해서 사용하는 데 익숙하지 않은 개발자
- 실전 감각을 키우고 싶은 주니어 백엔드 개발자

목표

사용자가 실제 문제 상황에서 Java Stream API를 적용하는 연습을 반복적으로 수행하도록 돕는다.

이를 위해:

- 다양한 실전형 예제를 퀴즈 형태로 제공하고
- 사용자의 코드를 AI가 분석·채점하며
- 학습 결과를 종합 리포트 형태로 제공한다.

최종적으로 사용자가 다음과 같은 역량을 갖추도록 하는 것이 목표다.

- 반복문 기반 사고에서 Stream 기반 사고로 전환할 수 있는 능력
- Stream 연산을 상황에 맞게 조합할 수 있는 실전 감각

주요 기능

1. AI 기반 퀴즈 출제
- AI가 Stream API를 활용할 수 있는 실전 예제 상황을 생성한다.
- 문제는 단순 문법 문제가 아닌, 실제 서비스 로직을 가정한 문제로 구성한다.
1.  문제 수 및 난이도 선택
    - 사용자는 다음을 선택할 수 있다.
        - 문제 개수
        - 난이도 (상 / 중 / 하)
    - 난이도에 따라:
        - 하: 단일 연산 중심 (filter, map 등)
        - 중: 복합 연산 및 Collectors 활용
        - 상: 그룹핑, 통계 처리, 복잡한 체이닝 등
2.  AI 코드 채점 및 분석
- 사용자가 작성한 코드를 AI가 분석한다.
    - 단순 정답 여부뿐 아니라 다음을 함께 평가한다.
        - Stream 사용의 적절성
        - 가독성
        - 불필요한 연산 여부
        - 더 나은 Stream 표현 가능성
1. 종합 학습 보고서 제공
- 모든 문제 풀이가 완료되면 AI가 종합 리포트를 생성한다.
    - 리포트에는 다음이 포함된다.
        - 전체 정답률
        - 문제 유형별 강점 / 약점
        - 코드 스타일 분석 (예: 가독성, 체이닝 길이, 메서드 분리 여부 등)
        - 개선 방향 제안
        - 학습 결론 요약

사용 흐름

1. 사용자에게 문제 개수를 입력받는다.
2. 사용자에게 난이도를 입력받는다.
    - 난이도: 상 / 중 / 하 중 선택
3. 선택된 조건에 맞는 Stream API 활용 퀴즈를 출제한다.
4. 사용자는 문제에 대한 Java 코드를 작성하여 제출한다.
5. 설정한 문제 개수만큼 3~4번 과정을 반복한다.
6. 모든 문제 풀이가 끝나면 AI가 채점을 수행한다.
7. 사용자에게 종합 학습 보고서를 제공한다.
    - 정답률
    - 코드의 장점과 단점
    - 개선 제안
    - 최종 학습 요약
```

### 2. 프롬프트 개선 과정

- **처음 결과물의 문제점은 무엇이었나요?**

초기 버전에서 가장 어려웠던 부분은 비즈니스 상황을 충분히 설명하면서도 퀴즈 형식의 가독성을 유지하는 것이었습니다.

이 서비스는 단순한 문법 문제가 아니라, 실제 비즈니스 로직을 가정하고 해당 요구사항을 Stream으로 구현해보는 경험을 제공하는 것을 목표로 합니다. 따라서 사용자는 문제를 풀기 전에:

- 비즈니스 상황을 이해하고
- 도메인 객체의 구조를 파악하며
- 입력과 출력 조건을 정확히 해석해야 했습니다.

하지만 퀴즈 형식은 기본적으로 간결하고 빠르게 읽히는 구성을 전제로 합니다. 설명이 길어지면 읽는 부담이 커지고, 반대로 내용을 줄이면 맥락이 충분히 전달되지 않는 문제가 발생했습니다.

결국 핵심은  필수 정보를 빠짐없이 전달하면서도 읽기 흐름을 해치지 않는 구조로 재구성하는 것이 쉽지 않았다는 점이었습니다.

또 다른 문제는 문제 개수 입력 방식의 부적절함이었습니다.

초기 구현에서는 슬라이더(막대바)를 통해 문제 개수를 조절하도록 설계했습니다. 그러나 문제 개수는 대략적인 범위를 선택하는 값이 아니라, 3개·5개처럼 명확한 숫자를 정확히 지정해야 하는 요소입니다. 슬라이더 방식은 감각적인 조절에는 적합하지만, 정밀한 선택이 필요한 상황에는 어울리지 않았습니다.

- **어떤 식으로 프롬프트를 수정했나요?**

```
1. 문제는 비즈니스 상황을 내기보다는 " /** * 주어진 문자열 리스트에서 길이가 5 이상인 문자열만을 포함하는 리스트를 반환합니다. * * @param strings 원본 문자열 리스트 * @return 길이가 5 이상인 문자열만 포함하는 리스트 */ public static List<String> filterStrings(List<String> strings) { return null; }
}"처럼 구현해야 할 상황을 줘.
2. 문제 개수는 키보드로 입력받도록 해줘
3. 디자인은 심플/미니멀하게 해줘
```

- **몇 번의 반복을 거쳤나요?**

15번 정도의 개선 과정을 거쳤습니다.

### 3. 효과적이었던 프롬프팅 전략

- **어떤 방식으로 요청했을 때 원하는 결과가 나왔나요?**

가장 효과적이었던 방식은, 제가 구상한 구체적인 로직과 처리 순서를 먼저 설명한 뒤 요청하는 방식이었습니다. 단순히 “이 기능을 만들어줘”라고 요청하기보다,

- 어떤 흐름으로 동작해야 하는지
- 어떤 조건이 필요한지
- 예상 입력과 출력은 무엇인지

를 명확히 제시한 뒤 예시를 함께 제공하면, 훨씬 의도에 가까운 결과를 얻을 수 있었습니다.

또한 한 번에 완성된 답을 기대하기보다, 결과를 받아본 뒤 제가 미처 고려하지 못한 부분을 하나씩 수정해나가는 반복적 개선 방식이 가장 효과적이었습니다.

- **반대로 효과가 없었던 방식은 무엇이었나요?**

앱 내의 단순한 문구나 메시지를 특정한 분위기나 어조로 바꿔달라고 요청하는 방식은 효율적이지 않았습니다.

짧은 문구 수정은 직접 다듬는 것이 더 빠르고 명확했으며, AI를 사용하는 것이 오히려 불필요한 반복 수정으로 이어지는 경우가 많았습니다.

### 4. 배운 점

- **Gemini Canvas를 효과적으로 사용하기 위한 나만의 팁이 있다면?**

제가 느낀 가장 효과적인 방법은, 요청의 방향을 먼저 간단히 설명한 뒤 개요 형식으로 요구사항을 구체화하는 방식입니다. 이를 통해 문장을 세세하게 다듬는 데 에너지를 쓰지 않으면서도, 핵심 요구사항을 빠짐없이 전달할 수 있었습니다.

### 5. 리뷰어에게 피드백 받고 싶은 포인트

초기 프롬프트의 사용 흐름이 요구사항을 충분히 설명하는지 그리고 가독성이 있는지에 대한 피드백을 받고싶습니다.

저는 캔버스에 앱 구현 요청을 하기 전에 앞서, 요구 사항을 명확히 작성해두려고 합니다. 특히 사용 흐름을 정확하게 정의하기위해 노력합니다. 왜냐하면 LLM에서 임의로 채워나가는 부분들은 대부분의 경우 제가 의도한 것과 달랐기 때문입니다.

그런데 사용 흐름을 작성하다 보면, 제가 적는 내용이 다른 사람들이 봤을 때도 충분히 이해가 가는지와 충분히 내용을 설명하고 있는지 궁금증이 들 때가 많았습니다. 이 부분에 대해 피드백을 주시면 감사하겠습니다!